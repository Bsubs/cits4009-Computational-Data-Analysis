---
title: "CITS4009 - Project 1"
author: "Joo Kai Tay (22489437)"
date: "2023-08-07"
output: 
  html_document:
    number_sections: true
---

# Introduction
The data set analyzed can be obtained from the Kaggle platform.
https://www.kaggle.com/datasets/nelgiriyewithana/global-youtube-statistics-2023

This data set contains information about 995 of the most subscribed YouTube channels in the world. The data set includes variables such as subscriber count, video views, upload frequency, country of origin and earnings. 

# Data loading, overview and set up

Load libraries
```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ggthemes)
library(numform)
library(treemapify)
library(timeDate)
library(lubridate)
library(dplyr)
library(reshape2)
library(ca)
library(shiny)
library(knitr)
```

The following code chunk sets up a theme for the charts used in this document. This is to ensure that all figures are coherent to improve the user viewing experience.
```{r}
cits4009_theme <- theme_few() + # Theme based on S. Few's "Practical Rules for Using Color in Charts"
                  theme(plot.title = element_text(color = "darkred")) +
                  theme(strip.text.x = element_text(size = 14, colour = "#202020")) +
                  theme(plot.margin=margin(10,30,10,30))
```

*Loading the data:*
```{r}
path <- './data/youtube_UTF_8.csv'
youtube <- read.csv(path)
```

## Data Cleaning and Transformation

## Data Exploratory
```{r}
str(youtube)
```
There are 995 observations of 28 variables, composed of 17 numerical, 7 character and 4 integer variables. It is of note that there are a number of overlapping variables in this data set, namely "Youtuber" and "Title", "category" and "channel_type" and "Country" and "Abbreviation". These will be dealt with in ***insert here** section. There are also some NaN values already visible from this brief inspection of the data which will need to be dealt with before displaying the data. 

## Analyzing the data using summary()
```{r}
summary(youtube)
```
## Transforming data
The date of the creation of a YouTube channel is given in 3 separate variables, "created_year", "created_month" and "created_date". The following function connects them together in the format YYYY-MM-DD and adds a new column to the youtube data frame.
```{r}
youtube$new_date_column <- paste(youtube$created_year, match(youtube$created_month, month.abb), sprintf("%02f", youtube$created_date), sep = "-")
```


## Dropping Variables / Observations

### Dropping duplicate variables 

As mentioned in ***insert here*** section, the following duplicate columns will be dropped from the dataset

```{r}
columns_to_drop <- c("Title", "channel_type", "Abbreviation")
youtube <- youtube[, !(names(youtube) %in% columns_to_drop)]
```

### Dropping observations where video views or uploads are 0
As seen from the summary of the data, there are channels with 0 uploads or video views. We are not interested in these channels as the data is likely to be incorrect given their pouplarity. Therefore, all observations with video views or uploads equal to 0 will be removed.  
```{r}
youtube <- youtube[(youtube$video.views != 0) & (youtube$uploads != 0), ]
```

### Dropping observations where created_date < 2005
YouTube was founded in 2005, therefore any observation with a channel creation year prior to 2005 are mistakes and will be removed from the data frame.
```{r}
youtube <- youtube[youtube$created_year >= 2005, ]
```


## Analyzing NaN Values
As mentioned in ***insert here*** section, there are a number of NaN values that have been spotted in the data. The following chunk shows the counts of NaN values for each variable.It is worth noting that the data set uses both NaN values, which can be detected by the r function `is.nan()` and "nan" values which are not counted by that function. Therefore, a modification to the counting function was required to acquire the full scope of the NaN values. 
```{r, echo=FALSE}
count_nan_values <- function(dataframe) {
  nan_counts <- sapply(dataframe, function(col) sum(is.nan(col) | is.na(col) | col=="nan"))
  nan_counts <- nan_counts[nan_counts > 0]
  nan_counts
}
count_nan_values(youtube)
```

```{r, echo=FALSE}
columns_of_interest <- c("Population", "Unemployment.rate", "Urban_population", "Latitude", "Longitude")
countries_with_nan <- youtube$Country[apply(youtube[columns_of_interest], 1, function(row) any(is.nan(row) | is.na(row)))]
# Filter out unique country names and remove duplicates
countries_with_nan <- unique(countries_with_nan)
# Create an empty dataframe to store the results
nan_counts_dataframe <- data.frame(Country = character(0), Population = integer(0), Unemployment = integer(0), Urban = integer(0), Latitude = integer(0), Longitude = integer(0))
# Loop through each country and calculate NaN counts
for (country in countries_with_nan) {
  country_rows <- youtube$Country == country
  nan_counts <- apply(youtube[country_rows, columns_of_interest], 2, function(col) sum(is.nan(col) | is.na(col)))
  nan_counts_dataframe <- rbind(nan_counts_dataframe, cbind(Country = country, as.data.frame(t(nan_counts))))
}

nan_counts_dataframe
```
There are 95 observations which do not have a country listed, and accordingly, these observations are also missing the relevant demographic information. The last observation that is missing demographic information is the country of Andorra. The following chunk will examine the 

# Analysis of Data 

## Single Variable Plots

### Numerical Data

The following chart visualizes the numerical variables in the data set as a shiny application. There are options for three types of charts, box plots, histograms and density plots. Furthermore, as this data set contains a large number of outliers, we have the option to limit the viewing of the charts to the 4 quartiles to improve the viewing experience. 
```{r, echo=FALSE}
numeric_columns <- sapply(youtube, is.numeric)
youtube_numeric <- youtube[, numeric_columns]
# UI part of the Shiny app
ui <- fluidPage(
  titlePanel("YouTube Data Visualization"),
  sidebarLayout(
    sidebarPanel(
      selectInput("x_var", "Select X Variable:", choices = colnames(youtube_numeric)),
      selectInput("plot_type", "Select Plot Type:",
                  choices = c("Boxplot", "Density Plot", "Histogram")),
      conditionalPanel(
        condition = "input.plot_type == 'Histogram'",
        sliderInput("binwidth", "Binwidth:", min = 1, max = 100, value = 5)
      ),
      checkboxInput("limit_range", "Limit to Q1-Q3 Range", value = FALSE)
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

# Server part of the Shiny app
server <- function(input, output) {
  output$plot <- renderPlot({
    x_var <- input$x_var
    plot_type <- input$plot_type
    limit_range <- input$limit_range
    binwidth <- input$binwidth
    
    p <- ggplot(youtube_numeric, aes_string(x = x_var))
    if (limit_range) {
      p <- p +  
            switch(plot_type,
           "Boxplot" = geom_boxplot(),
           "Density Plot" = geom_density(),
           "Histogram" = geom_histogram(binwidth = binwidth, aes_string(x = x_var))) +
        labs(title = paste(plot_type, " (Q1-Q3 Range)")) +
        xlim(boxplot.stats(youtube_numeric[[x_var]])$stats[1], boxplot.stats(youtube_numeric[[x_var]])$stats[4])
    } else {
      p <- p +
        switch(plot_type,
               "Boxplot" = geom_boxplot(),
               "Density Plot" = geom_density(),
               "Histogram" = geom_histogram(aes_string(x = x_var), binwidth = binwidth)) +
        labs(title = plot_type)
    }
    
    print(p)
  })
}

# Run the Shiny app
shinyApp(ui, server)
```

### Categorical Data

```{r, echo=FALSE}
categorical_columns <- sapply(youtube, function(col) !is.numeric(col))
youtube_categorical <- youtube[, categorical_columns]

# Update the UI with the slider input
ui <- fluidPage(
  titlePanel("YouTube Categorical Data Analysis"),
  sidebarLayout(
    sidebarPanel(
      selectInput(inputId = "variable", label = "Select a variable:", 
                  choices = colnames(youtube_categorical)),
      sliderInput(inputId = "num_levels", label = "Number of Levels to Show:",
                  min = 10, max = 995, value = 10, step = 1)
    ),
    mainPanel(
      plotOutput(outputId = "barplot")
    )
  )
)

# Define server
server <- function(input, output) {
  output$barplot <- renderPlot({
    selected_variable <- input$variable
    num_levels_to_show <- input$num_levels  # Get the selected number of levels
    
    # Count the levels of the selected categorical variable
    counts <- youtube_categorical %>% 
      count(.data[[selected_variable]])
    
    # Sort levels by counts in descending order
    sorted_levels <- counts %>% 
      arrange(desc(n)) %>% 
      pull(.data[[selected_variable]])
    
    # Reorder the factor levels based on sorted levels
    youtube_categorical[[selected_variable]] <- factor(
      youtube_categorical[[selected_variable]],
      levels = sorted_levels
    )
    
    # Subset data based on selected number of levels and create plot
    subset_data <- youtube_categorical %>%
      filter(.data[[selected_variable]] %in% sorted_levels[1:num_levels_to_show])
    
    ggplot(data = subset_data, aes(x = reorder(.data[[selected_variable]], desc(.data[[selected_variable]])))) +
      geom_bar() +
      coord_flip() +  
      labs(title = paste("Bar Chart of", selected_variable),
           x = selected_variable,
           y = "Count")
  })
}

# Run the app
shinyApp(ui = ui, server = server)
```
## Multi Variable Plots






















