---
title: "CITS4009 - Project 1"
author: "Joo Kai Tay (22489437)"
date: "2023-08-07"
output: 
  html_document:
    number_sections: true
---

# Introduction
The data set analyzed can be obtained from the Kaggle platform.
https://www.kaggle.com/datasets/nelgiriyewithana/global-youtube-statistics-2023

This data set contains information about 995 of the most subscribed YouTube channels in the world. The data set includes variables such as subscriber count, video views, upload frequency, country of origin and earnings. 

# Data loading, overview and set up

Load libraries
```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ggthemes)
library(numform)
library(treemapify)
library(timeDate)
library(lubridate)
library(dplyr)
library(reshape2)
library(ca)
library(shiny)
library(knitr)
```

The following code chunk sets up a theme for the charts used in this document. This is to ensure that all figures are coherent to improve the user viewing experience.
```{r}
cits4009_theme <- theme_few() + # Theme based on S. Few's "Practical Rules for Using Color in Charts"
                  theme(plot.title = element_text(color = "darkred")) +
                  theme(strip.text.x = element_text(size = 14, colour = "#202020")) +
                  theme(plot.margin=margin(10,30,10,30))
```

*Loading the data:*
```{r}
path <- './data/Global YouTube Statistics.csv'
youtube <- read.csv(path)
```

## Data Cleaning and Transformation

## Data Exploratory
```{r}
str(youtube)
```
There are 995 observations of 28 variables, composed of 17 numerical, 7 character and 4 integer variables. It is of note that there are a number of overlapping variables in this data set, namely "Youtuber" and "Title", "category" and "channel_type" and "Country" and "Abbreviation". These will be dealt with in ***insert here** section. There are also some NaN values already visible from this brief inspection of the data which will need to be dealt with before displaying the data. 

## Analyzing the data using summary()
```{r}
summary(youtube)
```
## Dropping Variables / Observations

### Dropping duplicate variables 

As mentioned in ***insert here*** section, the following duplicate columns will be dropped from the dataset

```{r}
columns_to_drop <- c("Title", "channel_type", "Abbreviation")
youtube <- youtube[, !(names(youtube) %in% columns_to_drop)]
```

### Dropping observations where video views or uploads are 0
As seen from the summary of the data, there are channels with 0 uploads or video views. We are not interested in these channels as the data is likely to be incorrect given their pouplarity. Therefore, all observations with video views or uploads equal to 0 will be removed.  
```{r}
youtube <- youtube[(youtube$video.views != 0) & (youtube$uploads != 0), ]
```

### Dropping observations where created_date < 2005
YouTube was founded in 2005, therefore any observation with a channel creation year prior to 2005 are mistakes and will be removed from the data frame.
```{r}
youtube <- youtube[youtube$created_year >= 2005, ]
```


## Analyzing NaN Values
As mentioned in ***insert here*** section, there are a number of NaN values that have been spotted in the data. The following chunk shows the counts of NaN values for each variable.It is worth noting that the data set uses both NaN values, which can be detected by the r function `is.nan()` and "nan" values which are not counted by that function. Therefore, a modification to the counting function was required to acquire the full scope of the NaN values. 
```{r}
count_nan_values <- function(dataframe) {
  nan_counts <- sapply(dataframe, function(col) sum(is.nan(col) | is.na(col) | col=="nan"))
  nan_counts <- nan_counts[nan_counts > 0]
  nan_counts
}
count_nan_values(youtube)
```

```{r}
columns_of_interest <- c("Population", "Unemployment.rate", "Urban_population", "Latitude", "Longitude")
countries_with_nan <- youtube$Country[apply(youtube[columns_of_interest], 1, function(row) any(is.nan(row) | is.na(row)))]
# Filter out unique country names and remove duplicates
countries_with_nan <- unique(countries_with_nan)
# Create an empty dataframe to store the results
nan_counts_dataframe <- data.frame(Country = character(0), Population = integer(0), Unemployment = integer(0), Urban = integer(0), Latitude = integer(0), Longitude = integer(0))
# Loop through each country and calculate NaN counts
for (country in countries_with_nan) {
  country_rows <- youtube$Country == country
  nan_counts <- apply(youtube[country_rows, columns_of_interest], 2, function(col) sum(is.nan(col) | is.na(col)))
  nan_counts_dataframe <- rbind(nan_counts_dataframe, cbind(Country = country, as.data.frame(t(nan_counts))))
}

nan_counts_dataframe
```
There are 95 observations which do not have a country listed, and accordingly, these observations are also missing the relevant demographic information. The last observation that is missing demographic information is the country of Andorra.

# Analysis of Data 

```{r}
numeric_columns <- sapply(youtube, is.numeric)
youtube_numeric <- youtube[, numeric_columns]
# Define UI
ui <- fluidPage(
  titlePanel("Variable Density Plot"),
  
  sidebarLayout(
    sidebarPanel(
      sliderInput("bandwidth", "Bandwidth", min = 0.01, max = 20, value = 0.2, step = 0.01),
      selectInput("variable", "Select Variable", choices = colnames(youtube_numeric), selected = colnames(youtube_numeric)[1])
    ),
    
    mainPanel(
      plotOutput("density_plot")
    )
  )
)

# Define server
server <- function(input, output) {
  output$density_plot <- renderPlot({
    ggplot(youtube_numeric, aes(x = youtube_numeric[[input$variable]])) +
      geom_density(aes(fill = input$variable), alpha = 0.5, adjust = input$bandwidth) +
      labs(x = input$variable, y = "Density") +
      theme_minimal() +
      theme(legend.position = "none") +
      geom_vline(aes(xintercept = mean(youtube_numeric[[input$variable]], na.rm = TRUE)), color = "red", linetype = "dashed") +
      geom_vline(aes(xintercept = median(youtube_numeric[[input$variable]], na.rm = TRUE)), color = "blue", linetype = "dashed") +
      xlim(min(youtube_numeric[[input$variable]], na.rm = TRUE), max(youtube_numeric[[input$variable]], na.rm = TRUE)) +
      geom_text(aes(label = paste("Mean =", round(mean(youtube_numeric[[input$variable]], na.rm = TRUE), 2))), 
                x = mean(youtube_numeric[[input$variable]], na.rm = TRUE), y = 0.1, color = "red") +
      geom_text(aes(label = paste("Median =", round(median(youtube_numeric[[input$variable]], na.rm = TRUE), 2))), 
                x = median(youtube_numeric[[input$variable]], na.rm = TRUE), y = 0.15, color = "blue") +
      labs(title = "Density Plot with Adjustable Bandwidth")
  })
}

# Run the app
shinyApp(ui, server)
```























