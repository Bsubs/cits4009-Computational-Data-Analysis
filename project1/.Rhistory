library(ggplot2)
library(gridExtra)
library(dplyr)
library(ggthemes)
library(numform)
library(treemapify)
library(timeDate)
library(lubridate)
library(dplyr)
library(reshape2)
library(ca)
library(shiny)
library(knitr)
cits4009_theme <- theme_few() + # Theme based on S. Few's "Practical Rules for Using Color in Charts"
theme(plot.title = element_text(color = "darkred")) +
theme(strip.text.x = element_text(size = 14, colour = "#202020")) +
theme(plot.margin=margin(10,30,10,30))
path <- './data/Global YouTube Statistics.csv'
youtube <- read.csv(path)
str(youtube)
summary(youtube)
columns_to_drop <- c("Title", "channel_type", "Abbreviation")
youtube <- youtube[, !(names(youtube) %in% columns_to_drop)]
youtube <- youtube[(youtube$video.views != 0) & (youtube$uploads != 0), ]
youtube <- youtube[youtube$created_year >= 2005, ]
count_nan_values <- function(dataframe) {
nan_counts <- sapply(dataframe, function(col) sum(is.nan(col) | is.na(col) | col=="nan"))
nan_counts <- nan_counts[nan_counts > 0]
nan_counts
}
count_nan_values(youtube)
columns_of_interest <- c("Population", "Unemployment.rate", "Urban_population", "Latitude", "Longitude")
countries_with_nan <- youtube$Country[apply(youtube[columns_of_interest], 1, function(row) any(is.nan(row) | is.na(row)))]
# Filter out unique country names and remove duplicates
countries_with_nan <- unique(countries_with_nan)
# Create an empty dataframe to store the results
nan_counts_dataframe <- data.frame(Country = character(0), Population = integer(0), Unemployment = integer(0), Urban = integer(0), Latitude = integer(0), Longitude = integer(0))
# Loop through each country and calculate NaN counts
for (country in countries_with_nan) {
country_rows <- youtube$Country == country
nan_counts <- apply(youtube[country_rows, columns_of_interest], 2, function(col) sum(is.nan(col) | is.na(col)))
nan_counts_dataframe <- rbind(nan_counts_dataframe, cbind(Country = country, as.data.frame(t(nan_counts))))
}
nan_counts_dataframe
numeric_columns <- sapply(youtube, is.numeric)
youtube_numeric <- youtube[, numeric_columns]
# Define UI
ui <- fluidPage(
titlePanel("Variable Density Plot"),
sidebarLayout(
sidebarPanel(
sliderInput("bandwidth", "Bandwidth", min = 0.01, max = 20, value = 0.2, step = 0.01),
selectInput("variable", "Select Variable", choices = colnames(youtube_numeric), selected = colnames(youtube_numeric)[1])
),
mainPanel(
plotOutput("density_plot")
)
)
)
# Define server
server <- function(input, output) {
output$density_plot <- renderPlot({
ggplot(youtube_numeric, aes(x = youtube_numeric[[input$variable]])) +
geom_density(aes(fill = input$variable), alpha = 0.5, adjust = input$bandwidth) +
labs(x = input$variable, y = "Density") +
theme_minimal() +
theme(legend.position = "none") +
geom_vline(aes(xintercept = mean(youtube_numeric[[input$variable]], na.rm = TRUE)), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = median(youtube_numeric[[input$variable]], na.rm = TRUE)), color = "blue", linetype = "dashed") +
xlim(min(youtube_numeric[[input$variable]], na.rm = TRUE), max(youtube_numeric[[input$variable]], na.rm = TRUE)) +
geom_text(aes(label = paste("Mean =", round(mean(youtube_numeric[[input$variable]], na.rm = TRUE), 2))),
x = mean(youtube_numeric[[input$variable]], na.rm = TRUE), y = 0.1, color = "red") +
geom_text(aes(label = paste("Median =", round(median(youtube_numeric[[input$variable]], na.rm = TRUE), 2))),
x = median(youtube_numeric[[input$variable]], na.rm = TRUE), y = 0.15, color = "blue") +
labs(title = "Density Plot with Adjustable Bandwidth")
})
}
# Run the app
shinyApp(ui, server)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ggthemes)
library(numform)
library(treemapify)
library(timeDate)
library(lubridate)
library(dplyr)
library(reshape2)
library(ca)
library(shiny)
library(knitr)
cits4009_theme <- theme_few() + # Theme based on S. Few's "Practical Rules for Using Color in Charts"
theme(plot.title = element_text(color = "darkred")) +
theme(strip.text.x = element_text(size = 14, colour = "#202020")) +
theme(plot.margin=margin(10,30,10,30))
path <- './data/Global YouTube Statistics.csv'
youtube <- read.csv(path)
str(youtube)
summary(youtube)
columns_to_drop <- c("Title", "channel_type", "Abbreviation")
youtube <- youtube[, !(names(youtube) %in% columns_to_drop)]
youtube <- youtube[(youtube$video.views != 0) & (youtube$uploads != 0), ]
youtube <- youtube[youtube$created_year >= 2005, ]
count_nan_values <- function(dataframe) {
nan_counts <- sapply(dataframe, function(col) sum(is.nan(col) | is.na(col) | col=="nan"))
nan_counts <- nan_counts[nan_counts > 0]
nan_counts
}
count_nan_values(youtube)
columns_of_interest <- c("Population", "Unemployment.rate", "Urban_population", "Latitude", "Longitude")
countries_with_nan <- youtube$Country[apply(youtube[columns_of_interest], 1, function(row) any(is.nan(row) | is.na(row)))]
# Filter out unique country names and remove duplicates
countries_with_nan <- unique(countries_with_nan)
# Create an empty dataframe to store the results
nan_counts_dataframe <- data.frame(Country = character(0), Population = integer(0), Unemployment = integer(0), Urban = integer(0), Latitude = integer(0), Longitude = integer(0))
# Loop through each country and calculate NaN counts
for (country in countries_with_nan) {
country_rows <- youtube$Country == country
nan_counts <- apply(youtube[country_rows, columns_of_interest], 2, function(col) sum(is.nan(col) | is.na(col)))
nan_counts_dataframe <- rbind(nan_counts_dataframe, cbind(Country = country, as.data.frame(t(nan_counts))))
}
nan_counts_dataframe
numeric_columns <- sapply(youtube, is.numeric)
youtube_numeric <- youtube[, numeric_columns]
# Define UI
ui <- fluidPage(
titlePanel("Variable Density Plot"),
sidebarLayout(
sidebarPanel(
sliderInput("bandwidth", "Bandwidth", min = 0.01, max = 20, value = 0.2, step = 0.01),
selectInput("variable", "Select Variable", choices = colnames(youtube_numeric), selected = colnames(youtube_numeric)[1])
),
mainPanel(
plotOutput("density_plot")
)
)
)
# Define server
server <- function(input, output) {
output$density_plot <- renderPlot({
ggplot(youtube_numeric, aes(x = youtube_numeric[[input$variable]])) +
geom_density(aes(fill = input$variable), alpha = 0.5, adjust = input$bandwidth) +
labs(x = input$variable, y = "Density") +
theme_minimal() +
theme(legend.position = "none") +
geom_vline(aes(xintercept = mean(youtube_numeric[[input$variable]], na.rm = TRUE)), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = median(youtube_numeric[[input$variable]], na.rm = TRUE)), color = "blue", linetype = "dashed") +
xlim(min(youtube_numeric[[input$variable]], na.rm = TRUE), max(youtube_numeric[[input$variable]], na.rm = TRUE)) +
geom_text(aes(label = paste("Mean =", round(mean(youtube_numeric[[input$variable]], na.rm = TRUE), 2))),
x = mean(youtube_numeric[[input$variable]], na.rm = TRUE), y = 0.1, color = "red") +
geom_text(aes(label = paste("Median =", round(median(youtube_numeric[[input$variable]], na.rm = TRUE), 2))),
x = median(youtube_numeric[[input$variable]], na.rm = TRUE), y = 0.15, color = "blue") +
labs(title = "Density Plot with Adjustable Bandwidth")
})
}
# Run the app
shinyApp(ui, server)
youtube$created_date
youtube$created_month
youtube$created_year
youtube$new_date_column <- paste(youtube$created_year, match(youtube$created_month, month.abb), sprintf("%02d", youtube$created_date), sep = "-")
youtube$new_date_column
